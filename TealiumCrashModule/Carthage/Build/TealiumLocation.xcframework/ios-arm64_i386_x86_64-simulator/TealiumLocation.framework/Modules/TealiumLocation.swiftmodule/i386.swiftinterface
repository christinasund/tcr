// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target i386-apple-ios9.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TealiumLocation
import CoreLocation
import Foundation
import Swift
import TealiumCore
public class LocationModule : TealiumCore.Collector {
  final public let id: Swift.String
  public var config: TealiumCore.TealiumConfig
  public var tealiumLocationManager: TealiumLocation.TealiumLocationManagerProtocol?
  public var data: [Swift.String : Any]? {
    get
  }
  required public init(context: TealiumCore.TealiumContext, delegate: TealiumCore.ModuleDelegate?, diskStorage: TealiumCore.TealiumDiskStorageProtocol?, completion: ((Swift.Result<Swift.Bool, Swift.Error>, [Swift.String : Any]?)) -> Swift.Void)
  public func clearMonitoredGeofences()
  public var createdGeofences: [Swift.String]? {
    get
  }
  public var lastLocation: CoreLocation.CLLocation? {
    get
  }
  public var monitoredGeofences: [Swift.String]? {
    get
  }
  public func sendGeofenceTrackingEvent(region: CoreLocation.CLRegion, triggeredTransition: Swift.String)
  public func startLocationUpdates()
  public func stopLocationUpdates()
  public func startMonitoring(geofences: [CoreLocation.CLCircularRegion])
  public func stopMonitoring(geofences: [CoreLocation.CLCircularRegion])
  public func requestAuthorization()
  @available(iOS 14, *)
  public func requestTemporaryFullAccuracyAuthorization(purposeKey: Swift.String)
  @objc deinit
}
extension Tealium {
  public var location: TealiumLocation.LocationModule? {
    get
  }
}
extension Collectors {
  public static let Location: TealiumLocation.LocationModule.Type
}
extension TealiumConfig {
  public var desiredAccuracy: TealiumLocation.LocationAccuracy {
    get
    set
  }
  public var updateDistance: Swift.Double {
    get
    set
  }
  public var geofenceFileName: Swift.String? {
    get
    set
  }
  public var geofenceUrl: Swift.String? {
    get
    set
  }
  public var geofenceTrackingEnabled: Swift.Bool {
    get
    set
  }
  public var initializeGeofenceDataFrom: TealiumLocation.LocationConfig? {
    get
  }
  public var useHighAccuracy: Swift.Bool {
    get
    set
  }
}
public protocol TealiumLocationManagerProtocol {
  var createdGeofences: [Swift.String]? { get }
  var isAuthorized: Swift.Bool { get }
  @available(iOS 14.0, *)
  var isFullAccuracy: Swift.Bool { get }
  var lastLocation: CoreLocation.CLLocation? { get set }
  var locationAccuracy: Swift.String { get set }
  var monitoredGeofences: [Swift.String]? { get }
  func clearMonitoredGeofences()
  func disable()
  func requestAuthorization()
  @available(iOS 14, *)
  func requestTemporaryFullAccuracyAuthorization(purposeKey: Swift.String)
  func sendGeofenceTrackingEvent(region: CoreLocation.CLRegion, triggeredTransition: Swift.String)
  func startLocationUpdates()
  func startMonitoring(_ geofences: [CoreLocation.CLCircularRegion])
  func stopLocationUpdates()
  func stopMonitoring(_ geofences: [CoreLocation.CLCircularRegion])
}
public protocol LocationManagerProtocol {
  @available(iOS 14, *)
  var accuracyAuthorization: CoreLocation.CLAccuracyAuthorization { get }
  var activityType: CoreLocation.CLActivityType { get set }
  static func authorizationStatus() -> CoreLocation.CLAuthorizationStatus
  var distanceFilter: Swift.Double { get set }
  var desiredAccuracy: CoreLocation.CLLocationAccuracy { get set }
  var delegate: CoreLocation.CLLocationManagerDelegate? { get set }
  var monitoredRegions: Swift.Set<CoreLocation.CLRegion> { get }
  var pausesLocationUpdatesAutomatically: Swift.Bool { get set }
  func requestAlwaysAuthorization()
  func requestWhenInUseAuthorization()
  @available(iOS 14, *)
  func requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: Swift.String, completion: ((Swift.Error?) -> Swift.Void)?)
  func startUpdatingLocation()
  func stopUpdatingLocation()
  func startMonitoringSignificantLocationChanges()
  func stopMonitoring(for region: CoreLocation.CLRegion)
  func startMonitoring(for region: CoreLocation.CLRegion)
}
extension CLLocationManager : TealiumLocation.LocationManagerProtocol {
}
public enum LocationKey {
}
public enum LocationConfigKey {
}
public enum LocationConfig {
  case tealium
  case localFile(Swift.String)
  case customUrl(Swift.String)
}
public enum LocationAccuracy : Swift.String {
  case bestForNavigation
  case best
  case nearestTenMeters
  case nearestHundredMeters
  case reduced
  case withinOneKilometer
  case withinThreeKilometers
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@objc @_hasMissingDesignatedInitializers public class TealiumLocationManager : ObjectiveC.NSObject, CoreLocation.CLLocationManagerDelegate, TealiumLocation.TealiumLocationManagerProtocol {
  public var locationAccuracy: Swift.String
  public var isAuthorized: Swift.Bool {
    get
  }
  @available(iOS 14.0, *)
  public var isFullAccuracy: Swift.Bool {
    get
  }
  public var lastLocation: CoreLocation.CLLocation? {
    get
    set
  }
  public func requestAuthorization()
  @available(iOS 14.0, *)
  public func requestTemporaryFullAccuracyAuthorization(purposeKey: Swift.String)
  public func startLocationUpdates()
  public func stopLocationUpdates()
  @objc public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
  @objc public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: Swift.Error)
  @objc public func locationManager(_ manager: CoreLocation.CLLocationManager, didDetermineState state: CoreLocation.CLRegionState, for region: CoreLocation.CLRegion)
  @objc public func locationManager(_ manager: CoreLocation.CLLocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
  @available(iOS 14.0, *)
  @objc public func locationManagerDidChangeAuthorization(_ manager: CoreLocation.CLLocationManager)
  public func sendGeofenceTrackingEvent(region: CoreLocation.CLRegion, triggeredTransition: Swift.String)
  public func startMonitoring(_ geofences: [CoreLocation.CLCircularRegion])
  public func startMonitoring(geofence: CoreLocation.CLCircularRegion)
  public func stopMonitoring(_ geofences: [CoreLocation.CLCircularRegion])
  public func stopMonitoring(geofence: CoreLocation.CLCircularRegion)
  public var monitoredGeofences: [Swift.String]? {
    get
  }
  public var createdGeofences: [Swift.String]? {
    get
  }
  public func clearMonitoredGeofences()
  public func disable()
  @objc override dynamic public init()
  @objc deinit
}
public struct Geofence : Swift.Codable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case name
    case latitude
    case longitude
    case radius
    case triggerOnEnter
    case triggerOnExit
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Array where Element == TealiumLocation.Geofence {
  public var regions: [CoreLocation.CLCircularRegion] {
    get
  }
}
public struct GeofenceData : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension TealiumLocation.LocationAccuracy : Swift.Equatable {}
extension TealiumLocation.LocationAccuracy : Swift.Hashable {}
extension TealiumLocation.LocationAccuracy : Swift.RawRepresentable {}
extension TealiumLocation.Geofence.CodingKeys : Swift.Equatable {}
extension TealiumLocation.Geofence.CodingKeys : Swift.Hashable {}
extension TealiumLocation.Geofence.CodingKeys : Swift.RawRepresentable {}
